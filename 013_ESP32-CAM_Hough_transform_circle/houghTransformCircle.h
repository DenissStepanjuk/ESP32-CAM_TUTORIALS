// Cтандартная библиотека с набором математических функций.
#include <cmath>


/** Функция для отрисовки круга.
    uint8_t * &buf - изображение на которое будет нанесён круг.
    int x - координата центра круга.
    int y -  координата центра круга.
    int radius - радиус круга.
    int width - ширина изображения.
    int height - высота изображения.**/
void drawCircle(uint8_t * &buf, int x, int y, int radius, int width, int height) {

  // Корректируем часть аргументов для более удобной работы:
  // Отсчёт координат начинается с 0, а не 1.
  int y_real = y - 1;
  int x_real = x - 1;

  // Если окружность не выходит за границы изображения.
  if (x + radius < width + 1 && y + radius < height + 1) {
    // В заданой точке начертить окружность. 
    // Окружность это 360 градусов, для каждого направления требуется расчитать точку.
    for(int i = 0; i < 360 ; i += 1){
      // Угол для радиуса проведённого из центра окружности к расчитываемой точке.
      float theta = i*PI/180.0;
      // Координата x расчитываемой точки окружности.
      int xc = x_real + (radius * cos(theta));
      // Координата y расчитываемой точки.
      int yc = y_real + radius*sin(theta);
      // Индекс расчитываемой точки в буфере содержащем изображение.
      int bufIndex = yc * width + xc;

      if (bufIndex > 0 && bufIndex < width * height){
        // Окрашиваем точку окружности.
        buf[bufIndex] += 1;
        //buf[bufIndex + 1] += 1;
      }
    }     
  } 
}



/** Функция принимает изображение содержащие контуры исходной фотографии, преобразует его в пространство Хафа
и возращает параметры из пространства Хафа для построения окружностей по контурам на исходной фотографии. 
  uint8_t * buf_img - буфер с исходным изображением.
  size_t len_img - размер буфера.
  uint8_t * &buf_hough - буфер под хранение пространства хафа.
  size_t &len_hough - размер буфера.
  int radius - радиус искомой окружности.
  int width - ширина изображения.
  int height - высота изображения.**/
void computeHoughCircle(uint8_t * buf_img, size_t len_img, uint8_t * &buf_hough, size_t &len_hough, int radius, int width, int height){
  // Размер буффера для пространства Хафа.
  len_hough = len_img;
  // Инициализировать буфер под хранение пространства Хафа.
  buf_hough = (uint8_t *)ps_malloc(len_hough);

  // Приравнять все пиксели пространства Хафа к 0 чтобы получить изначально полностью чёрное изображение.
  for(int i = 0; i < len_hough ; i += 1){
    buf_hough[i] = 0;
  }

  // Переменная для итерации по буферу.
  int iter = 0;
  // Пройти через все пиксели изображения по вертикали.
  for(int y = 1; y <= height; y++){
    // Пройти через все пиксели изображения по горизонтали.
    for(int x = 1; x <= width; x++){
      // Если яркость текущего пикселя выше порогового значения, то текущий пиксель будет центром для построения окружности.
      if (buf_img[iter] > 200){
        // Построить окружность в пространстве Хафа.
        drawCircle(buf_hough, x, y, radius, width, height);
      }

      // Сделать шаг итерации по буферу.
      iter +=1;
    }
  }
}












/** Функция для отрисовки круга.
    uint8_t * &buf - изображение на которое будет нанесён круг.
    int x - координата центра круга.
    int y -  координата центра круга.
    int radius - радиус круга.
    int width - ширина изображения.
    int height - высота изображения.**/
void drawRGBCircle(uint8_t * &buf, int x, int y, int radius, int width, int height) {

  // Корректируем часть аргументов для более удобной работы:
  // Отсчёт координат начинается с 0, а не 1.
  int y_real = y - 1;
  // Сдвигаем координату "x", так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int x_real = (x - 1) * 3;
  // Увеличиваем ширину изображения, так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int width_real = width * 3;

  // Если окружность не выходит за границы изображения.
  if (x + radius < width + 1 && y + radius < height + 1) {
    // В заданой точке начертить окружность. 
    // Окружность это 360 градусов, для каждого направления требуется расчитать точку.
    for(int i = 0; i < 360 ; i += 1){
      // Угол для радиуса проведённого из центра окружности к расчитываемой точке.
      float theta = i*PI/180.0;
      // Координата x расчитываемой точки окружности с учётом, что на каждый 
      // пиксель приходиться 3 компоненты цвета RGB.
      int xc = x_real + (radius * cos(theta)) * 3;
      // Координата y расчитываемой точки.
      int yc = y_real + radius*sin(theta);
      // Индекс расчитываемой точки в буфере содержащем изображение.
      int bufIndex = yc * width_real + xc;

      // Закрашиваем рассчитанную точку окружности:
      // Красная компонента цвета.
      buf[bufIndex+2] = 255;
      // Зелёная компонента цвета.
      buf[bufIndex+1] = 255;
      // Голубая компонента цвета.
      buf[bufIndex] = 255;
    }     
  } else {
    Serial.println("The circle has gone beyond the image border!");
  }
}










/** Функция возвращает яркие точки из пространства Хафа для параметров, которые встречаются чаще остальных и удаляет шум.
    uint8_t * &buf_hough - Буфер в который записано представление изображения в пространстве Хафа.
    size_t &len_hough - Размер буфера содержащего пространство Хафа. 
    int diagonal - Ширина пространства Хафа. 
    int teta - Высота пространства Хафа. 
    int arr_R[50] - Массив для хранения параметров R (расстояние от начала координат к прямой под углом 90 градусов).
    int arr_theta[50] - Массив для хранения углов theta (угол наклона прямой "R" относительно оси x)
    int &linesFound - Количество найденых ярких точек в пространстве Хафа.
 **/
void getDotsFromHoughSpace(uint8_t * &buf_hough, size_t &len_hough, int width, int height, uint8_t arr_X[50], uint8_t arr_Y[50], int &circlesFound){
  // Пороговое значение для яркости точки.
  int threshold = 120;
  circlesFound = 0;

  // Пройти через все точки в пространстве Хафа.
  for(int i = 0; i < len_hough; i+=1){
    // Занулить все блеклые точки (улалить шум).
    if(buf_hough[i] <= threshold){
      buf_hough[i] = 0;
    }
  }

  // Переменые для временого хранения координат центра окружности.
  int x;
  int y;

  // Пройти через все точки в пространстве Хафа.
  for(int i = 0; i < len_hough; i+=1){
    // Если яркость пикселя в пространстве Хафа выше порогового значения, значит это центр окружности.
    if(buf_hough[i] > threshold){
      // Отметим что нашли центр окружности, дальше потребуется для проверки, возможно такая окружность уже была найдена.
      bool newLine = true;
      // Посчитаем координаты центра окружности.
      x = (i + 1) / width;
      y = (i + 1) - (x * width);

      // Если это первая найденая окружность, то запишем её без проверки.
      if(circlesFound == 0){
        arr_X[circlesFound] = x;
        arr_Y[circlesFound] = y;
        circlesFound += 1;
        newLine = false;
      } else {
        // Проверить окружность из массива для проверки на уникальность.
        // Сопоставить её со всеми найдеными окружностями, может быть окружность с близкими координатами уже есть.
        // Для этого между центрами каждой найденой окружности и проверяемой рассчитываем евклидово расстояние.
        for(int point = 0; point < circlesFound; point += 1){
          // Переменная будет хранить среднее значение евклидова расстояния между всеми точками двух линий.
          int distEuclidian = 0;
          // Рассчитаем евклидово расстояние между всеми парами точек у двух линий.
          distEuclidian = sqrt(pow(arr_X[point] - x, 2) + pow(arr_Y[point] - y, 2));
          // Если растояние между центрами окружностей меньше порогового значения.
          if(distEuclidian < 20) {
            // Найти среднее значение между координат центров окружностей.
            int midleX = (arr_X[point] + x) / 2;
            int midleY = (arr_Y[point] + y) / 2;
            // Перезаписать координаты центра окружности.
            arr_X[point] = midleX;
            arr_Y[point] = midleY;
            newLine = false;
          } 
        }
      }
      // Понизить яркость текущего пикселя в пространстве Хафа до нуля.
      buf_hough[i] = 0;
      // Если окружность прошла проверку на уникальность, то добавить новую окружность.
      if(newLine) {
        arr_X[circlesFound] = x;
        arr_Y[circlesFound] = y;
        circlesFound += 1;
      }
    }
  }
  // Отметить центр для каждой окружности в пространстве Хафа.
  for(int point = 0; point < circlesFound; point += 1){

    int dotIndex = arr_X[point] * width + arr_Y[point];

    buf_hough[dotIndex] = 255;

  }
}
