/** Функция берёт цветное изображение в формате JPEG  и преобразует его в чёрно-белое изображение.
      bool convert2jpeg - Если true, то возвращает изображение в формате JPEG. Если false, то возвращает матрицу.
      uint8_t * buf_jpeg - Буфер хранящий исходное изображение в формате JPEG.
      size_t len_jpeg - Размер исходного изображения.
      uint8_t * &buf_gray_out - Буфер для записи в него обработоного изображения.
      size_t &len_gray_out - Размер обработоного изображения.
      int width - Ширина исходного изображения.
      int height - Высота исходного изображения.**/
void jpeg2gray(bool convert2jpeg, uint8_t * buf_jpeg, size_t len_jpeg, uint8_t * &buf_gray_out, size_t &len_gray_out, int width, int height) {
  // Размер буффера для хранения исходного изображения преобразованого в цветовую матрицу RGB.
  size_t  len_rgb = width * height * 3;
  // Инициализировать буфер под хранение исходного изображения преобразованого в цветовую матрицу RGB.
  uint8_t *buf_rgb = (uint8_t *)ps_malloc(len_rgb);
  // Конвертируем исходное изображение в цветовую матрицу RGB.
  bool okey = fmt2rgb888(buf_jpeg, len_jpeg, PIXFORMAT_JPEG, buf_rgb);
  // Если удалось представить изображение в виде цветовой матрицы, чтоб каждому пикселю соответствовало 3 значения: R, G, B.
  if (okey) {
    // Размер буффера для матрицы содержащей чёрно-белое изображение.
    size_t len_gray = width * height;
    // Инициализировать буфер под хранение матрицы содержащей чёрно-белое изображение.
    uint8_t *buf_gray = (uint8_t *)ps_malloc(len_gray);
    // Переменная для итерации по буферу в который записывается чёрно-белое изображение.
    int iter_gray = 0;
    // Проходим через все пиксели цветовой матрицы содержащей исходное изображение чтобы 
    // получить матрицу содержащую чёрно-белое изображение.
    for(int i = 0; i < len_rgb; i += 3){
      // Пиксель чёрно-белого изображния состоит из одной компоненты, а пиксель цветного изображения состоит из 3 компонент RGB.
      // Чтобы получить чёрно-белый пиксель требуется сложить 3 компоненты цветного пикселя по следующей формуле:
      // чёрно-белый пиксель = 0.114*синяя компонента + 0.587*зелёная компонента + 0.299*красная компонента.
      buf_gray[iter_gray] = (int)(0.114*buf_rgb[i] + 0.587*buf_rgb[i+1] + 0.299*buf_rgb[i+2]);
      // Сделать шаг итерации по буферу.
      iter_gray +=1;
    }
    // Освобождаем буфер хранящий исходное изображение преобразованое в цветовую матрицу RGB.
    if (buf_rgb) free(buf_rgb);
    // Если требуется конвертировать матрицу хранящую чёрно-белое изображение в формат JPEG.
    if(convert2jpeg){
      // Конвертируем чёрно-белое изображения в сжатое изображение в формате JPEG.
      bool ok2 = fmt2jpg(buf_gray, len_gray, width, height, PIXFORMAT_GRAYSCALE, 80, &buf_gray_out, &len_gray_out);
      // Освобождаем буфер хранящий чёрно-белую матрицу.
      if (buf_gray) free(buf_gray);
    } else{
      // Возвращаем буфер хранящий чёрно-белую матрицу.
      buf_gray_out = buf_gray;
      // Возвращаем размер буфера хранящего чёрно-белую матрицу.
      len_gray_out = len_gray;
      // Освобождаем буфер хранящий чёрно-белую матрицу.
    }
  }
} 



/** Функция для детекции границ линии на чёрно-белом изображении.
    uint8_t * buf - буфер с чёрно-белым изображением.
    size_t len - размер буфера.
    int width - ширина изображения.
    int height - высота изображения.
    int verticalCoordinate - (горизонталь) координата (Y) по которой будет расчитыватся разница между пикселями.
    int &leftBorder - переменная в которую будет записана координата (X) левой границы линии.
    int &center - переменная в которую будет записана координата (X) центра линии.
    int &rightBorder - переменная в которую будет записана координата (X) правой границы линии.
    int diffValuesArray[320 - 1] - массив в который будут записаны все значения разницы между парами пикселей.**/
void findBorders(uint8_t * buf, size_t len, int width, int height, int verticalCoordinate, int &leftBorder, int &center, int &rightBorder, int diffValuesArray[320 - 1]) {
  
  //  Переменная хранящая разницу между двумя пикселями.
  int diffValue = 0;
  //  Переменная хранящая минимальную разницу между двумя пикселями.
  int minValue = 0;
  //  Переменная хранящая максимальную разницу между двумя пикселями.
  int maxValue = 0;

  //  Пройти по всем пикселям выбраной горизонтали.
  for(int i = 0; i < width - 1; i += 1){
    // Рассчитать разницу между текущем пикселем и следующим за ним.
    diffValue = buf[verticalCoordinate * height + i] - buf[verticalCoordinate * height + i + 1];
    // Записать разницу между текущем пикселем и следующим за ним в массив.
    diffValuesArray[i] = diffValue;

    // Если минимальная разница между двумя пикселями больше, чем текущая разница между двумя пикселями,
    if( minValue > diffValue ){
      // то следует обновить значение минимальной разницы между двумя пикселями
      minValue = diffValue;
      // и обновить координату (X) правой границы.
      rightBorder = i;
    }

    // Если максимальная разница между двумя пикселями меньше, чем текущая разница между двумя пикселями,
    if( maxValue < diffValue ){
      // то следует обновить значение максимальной разницы между двумя пикселями
      maxValue = diffValue;
      // и обновить координату (X) левой границы.
      leftBorder = i;
    }
  }
  // Рассчитать координату (X) центра между правой и левой границей.
  center = (leftBorder + rightBorder) / 2;
}




