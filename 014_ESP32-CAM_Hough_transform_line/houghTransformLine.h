// Cтандартная библиотека с набором математических функций.
#include <cmath>

/** Функция принимает изображение содержащие контуры исходной фотографии, преобразует его в пространство Хафа
    и возращает параметры из пространства Хафа для построения прямых линий лежащих по контурам на исходной фотографии.
    uint8_t * buf_img - Буфер изображения содержащего контуры исходной фотографии.
    size_t len_img - Размер буфера содержащего контуры исходной фотографии.
    uint8_t * &buf_hough - Буфер в который будет записано представление изображения в пространстве Хафа.
    size_t &len_hough -  Размер буфера содержащего пространство Хафа. 
    int width - Ширина изображения с контурами.
    int height - Высота изображения с контурами.
    int &diagonal - Ширина пространства Хафа. 
    int &teta - Высота пространства Хафа. 
**/
void computeHoughLine(uint8_t * buf_img, size_t len_img, uint8_t * &buf_hough, size_t &len_hough, int width, int height, int &diagonal, int &teta){
  // Шириной пространства Хафа будет диагональ изображения содержащего контуры исходной фотографии помноженая на 2.
  diagonal = (int) ( ( sqrt (pow(width, 2) + pow(height, 2) ) ) * 2 );
  // Высотой пространства Хафа будет диапозон угла teta от -90 до 90 градусов.
  teta = 181;
  // Размер буффера для пространства Хафа.
  len_hough = diagonal * teta;
  // Инициализировать буфер под хранение пространства Хафа.
  buf_hough = (uint8_t *)ps_malloc(len_hough);
  // Приравнять все пиксели пространства Хафа к 0 чтобы получить изначально полностью чёрное изображение.
  for(int i = 0; i < len_hough ; i += 1){
    buf_hough[i] = 0;
  }

  // Длинна прямой "R" выходящей из начала координат и прилегающей к искомой прямой под углом 90 градусов.
  // Расстояние от начала координат к прямой под углом 90 градусов.
  int R = 0;
  // Переменная для итерации по буферу изображения содержащего контуры исходной фотографии.
  int iterContours = 0;
  // Переменная для итерации по буферу содержащему пространство Хафа.
  int bufHoughIndex;
  // Пройти через все пиксели изображения по вертикали.
  for(int y = 1; y <= height; y+=1){
    // Пройти через все пиксели изображения по горизонтали.
    for(int x = 1; x <= width; x+=1){
      // Если текущий пиксель на изображении содержащем контуры исходной фотографии белый, то
      if (buf_img[iterContours] > 200){
        // от начала координат под углом "T" ( от - 90 до 90 градусов) рассчитаем
        for(int T = -90; T <= 90; T+=1){
          // Длинну прямой "R" выходящей из начала координат под углом "T" и прилегающую к прямой проходящей через этот пиксель под углом 90 градусов.
          R = x * cos(T) + y * sin(T);

          // Имея угол "T" (угол наклона прямой "R" относительно оси x) и длинну прямой "R" выходящей из начала координат под углом "T"
          // рассчитаем индекс для буфера содержащего пространство Хафа соответсвующий точке в этом пространстве для этих параметров.
          bufHoughIndex = (T + 90) * diagonal + diagonal/2 + R;

          // Если яркость этой точки в пространстве Хафа высокая, то оставляем её высокой.
          if(buf_hough[bufHoughIndex] > 250){
            buf_hough[bufHoughIndex] = 255;
          } else {
            // Увеличиваем яркость этой точки в пространстве Хафа.
            buf_hough[bufHoughIndex] += 1;
          }
        }
      }
      // Сделать шаг итерации по буферу изображения содержащего контуры исходной фотографии..
      iterContours +=1;
    }
  }
}


/** Функция возвращает яркие точки из пространства Хафа для параметров, которые встречаются чаще остальных и удаляет шум.
    uint8_t * &buf_hough - Буфер в который записано представление изображения в пространстве Хафа.
    size_t &len_hough - Размер буфера содержащего пространство Хафа. 
    int diagonal - Ширина пространства Хафа. 
    int teta - Высота пространства Хафа. 
    int arr_R[50] - Массив для хранения параметров R (расстояние от начала координат к прямой под углом 90 градусов).
    int arr_theta[50] - Массив для хранения углов theta (угол наклона прямой "R" относительно оси x)
    int &linesFound - Количество найденых ярких точек в пространстве Хафа.
 **/
void getDotsFromHoughSpace(uint8_t * &buf_hough, size_t &len_hough, int diagonal, int teta, uint8_t arr_R[50], uint8_t arr_theta[50], int &linesFound){
  // Пороговое значение для яркости точки.
  int threshold = 60;

  // Пройти через все точки в пространстве Хафа.
  for(int i = 0; i < len_hough; i+=1){
    // Занулить все блеклые точки (улалить шум).
    if(buf_hough[i] <= threshold){
      buf_hough[i] = 0;
    }
  }

  // Часть точек не являються таковыми, а представляют собой отрезок растянутый по оси 'X'.
  // Для удобства оставим от отрезка лишь центральную точку, а те что по бокам отрезка занулим.
  // Пройдём через все точки в пространстве Хафа.
  for(int i = 0; i < len_hough; i+=1){
    // Переменная будет хранить длинну отрезка от которого надо будет оставить лишь центральную точку.
    int dotLen = 0;
    // Если i-ая точка в пространстве Хафа белая,
    if(buf_hough[i] >= threshold){
      // увеличим длинну отрезка с 0 до 1 точки.
      dotLen += 1;
      // Пройдём через все точки лежащие справа от i-ой точки.
      do {
        // Если яркость точки лежащей справа от i-ой больше порогового значения,
        if(buf_hough[i + dotLen] >= threshold){
          // увеличим длинну отрезка на 1.
          dotLen += 1;
        } // До тех пор пока не упрёмся в чёрную точку.
      } while (buf_hough[i + dotLen] >= threshold);
    }
    // Получим центр отрезка.
    int dotSelect = dotLen / 2;
    // Занулим все точки отрезка кроме центральной.
    for(int g = 0; g < dotLen; g+=1){
      if(g != dotSelect){
        buf_hough[i + g] = 0;
      }
    }
  }

  // Переменная для итерации по массивам содержащим параметры из пространства Хафа.
  int iterArrays = 0;
  // Переменная для подсчёта найденых линий.
  linesFound = 0;
  // Пройти через все пиксели пространства Хафа.
  for(int z = 0; z < len_hough; z+=1){
    // Если яркость пикселя в пространстве Хафа выше порогового значения,
    if(buf_hough[z] >= threshold){
      // Выделим из пространства Хафа в текущей точке угол theta (угол наклона прямой "R" относительно оси x).
      int T_arg = (z / diagonal);
      // Выделим из пространства Хафа в текущей точке длинну прямой "R" выходящей из начала координат 
      // и прилегающей к искомой прямой под углом 90 градусов.
      int R_arg = z - (T_arg * diagonal) - (diagonal / 2);
      // Запишем полученные из пространства Хафа параметры в соответсвующие массивы.
      if(iterArrays<50){
        arr_theta[linesFound] = T_arg;
        arr_R[linesFound] = R_arg;
        // Отметим что была найдена ещё одна линия.
        linesFound += 1;
      }
    // Сделать шаг итерации по массивам содержащим параметры из пространства Хафа.
    iterArrays +=1;
    }
  }
}



/** Функция для построения всех линий найденых в пространстве Хафа.
    uint8_t * &buf - буфер изображения для построения прямых линий по данным из пространства Хафа.
    size_t &len -  размер буфера.
    int width - ширина изображения.
    int height - высота изображения
    int arr_R[50] - массив параметров R полученых из пространства Хафа
    int arr_theta[50] - массив параметров theta полученых из пространства Хафа
    int linesFound - кол-во найденых ярких точек в пространстве Хафа.
**/
void drawAllLines(uint8_t * &buf, size_t &len, int width, int height, uint8_t arr_R[50], uint8_t arr_theta[50], int linesFound){
  // Переменная для хранение размера буфера содержащего прямые линии построеные по данным из пространства Хафа.
  len = width * height;
  // Инициализировать буфер содержащий прямые линии построеные по данным из пространства Хафа.
  buf = (uint8_t *)ps_malloc(len);
  // Приравнять все пиксели буфера содержащего прямые линии построеные по данным из пространства Хафа к 0 чтобы получить изначально полностью чёрное изображение.
  for(int i = 0; i < len ; i += 1){
    buf[i] = 0;
  }

  for(int i = 0; i < 50; i+=1){
      // На изображении для прямых линий построеных по данным из пространства Хафа.
      int T_arg = arr_theta[i];
      int R_arg = arr_R[i];
      for (int X = 0; X < width; X+=1){
        // Имея координату "X" (ширина) рассчитать координату "Y" (точку высота)
        // чтобы получить координаты точки прямой линии, которую мы строим по данным из пространства Хафа.
        //int Y = -(cos(arr_theta[i] - 90) / sin(arr_theta[i] - 90) * X) + (arr_R[i] / sin(arr_theta[i] - 90));
        int Y = (-(cos(T_arg-90) / sin(T_arg-90) * X) + (R_arg / sin(T_arg-90)));

        // Если координата "Y" (высота) не выходит за рамки изображения
        if(Y > 0 && Y < height){
          // Рассчитать индекс для буфера изображения прямых линий, построеных по данным из пространства Хафа,
          // соответствующий точке с расчитанными координатами для прямой линнии .
          int bufIndexFound = Y * width + X;
          // Если рассчитаный индекс не превышает размер буфера
          if(bufIndexFound < len){
            // покрасить соответсвующий пиксель в белый.
            buf[bufIndexFound] = 250;
          }
        }
      }
  }
}




/** Так как из пространства Хафа из-за шумов возвращается много линий лежащих на похожих траекториях, их требуется отфильтровать
и вернуть по одной линии для каждой грани на изображении.
uint8_t * &buf - буфер изображения для построения прямых отфильтрованых линий по данным из пространства Хафа.
size_t &len -  размер буфера.
int width - ширина изображения.
int height - высота изображения
int arr_R[50] - массив параметров R полученых из пространства Хафа
int arr_theta[50] - массив параметров theta полученых из пространства Хафа
int arr_lines[6][238] - массив под хранение координат отфильтрованых линий по данным из пространства Хафа.
int linesFound - кол-во найденых ярких точек в пространстве Хафа.
int &linesSorted - кол-во найденых отфильтрованых линий. **/
void drawFiltredLines(uint8_t * &buf, size_t &len, int width, int height, uint8_t arr_R[50], uint8_t arr_theta[50], int arr_lines[6][238], int linesFound, int &linesSorted){
  // Переменная для хранение размера буфера содержащего прямые линии построеные по данным из пространства Хафа.
  len = width * height;
  // Инициализировать буфер содержащий прямые линии построеные по данным из пространства Хафа.
  buf = (uint8_t *)ps_malloc(len);
  // Приравнять все пиксели буфера содержащего прямые линии построеные по данным из пространства Хафа к 0 чтобы получить изначально полностью чёрное изображение.
  for(int i = 0; i < len ; i += 1){
    buf[i] = 0;
  }

  // Пройти через все параметры полученные из пространства Хафа. 
  for(int i = 0; i < linesFound; i+=1){
    // i-ый угол "T" тета полученный из пространства Хафа. 
    int T_arg = arr_theta[i];
    // i-ая прямая "R" выходящая из начала координат под углом "T" тета и прилегающая к искомой прямой под углом 90 градусов.
    int R_arg = arr_R[i];

    // Массив хранящий линию для проверки.
    int arr_Y[238];
    // Введём среднее значение для "y" что поможет определить находится ли линия за пределами изображения.
    int Y_average = 0;

    // Для каждого "X" рассчитаем "Y" и запишем в массив хранящий линию для проверки.
    for(int x = 0; x < width; x += 1){

      // Найдём значение "y" в точке "x".
      int Y = (-(cos(T_arg-90) / sin(T_arg-90) * x) + (R_arg / sin(T_arg-90)));
      // Все значения "y" выходящие за рамки изображения приравнять к единому значению.
      if (Y < 0) { Y = -1;}
      if (Y > 238) { Y = 239;}
      // Запишем значение "y" в массив.
      arr_Y[x] =  (-(cos(T_arg-90) / sin(T_arg-90) * x) + (R_arg / sin(T_arg-90)));
      // Сумма всех значений "y" для этой линии.
      Y_average += Y;
    }
    // Среднее значение  "y".
    Y_average /= height;
    // Если линия проходит за пределами изображения, то перейти к расчёту значений для новой линии.
    if(Y_average < 0 || Y_average > height){ continue; }


      // Флаг помогает определить является ли линия построеная по  i-тым параметрам уникальной или повторением уже существующей.
      bool newLine = true;
      // Если это первая линия рассматриваемая нами, то запишем её в список без проверок.
      if(linesSorted == 0){
        // Для каждого "X" рассчитаем "Y" и запишем в массив хранящий все линии.
        for(int x = 0; x < width; x += 1){
          arr_lines[0][x] =  arr_Y[x];
        }
        // В массив arr_lines добавлена одна линия.
        linesSorted += 1;
        // В этой итерации цикла больше не надо добавлять линий в  массив arr_lines.
        newLine = false;
      } else{
        // Проверить линию из массива для проверки на уникальность.
        // Сопоставить её со всеми найдеными линиями, может быть линия проходящая по похожей траектории уже есть.
        // Для этого между точками каждой найденой линии и проверяемой рассчитываем евклидово расстояние.
        for(int l = 0; l < linesSorted; l += 1){
          // Переменная будет хранить среднее значение евклидова расстояния между всеми точками двух линий.
          int distEuclidian = 0;
          // Рассчитаем евклидово расстояние между всеми парами точек у двух линий.
          for(int x = 0; x < width; x += 1){
            distEuclidian += sqrt(pow(arr_lines[l][x] - arr_Y[x], 2));
          }
          // Получаем усреднённое евклидово расстояние между всеми парами точек у двух линий.
          distEuclidian /= width;
          // Если усреднённое евклидово расстояние меньше порогового значения, значит такая линия уже есть.
          if(distEuclidian < 30){
            // Так как мы получили две линии проходящие по одному контуру на фотографии, то наиболее точно расположения контура
            // на изображении покажет среднее значение этих двух линий.
            for(int x = 0; x < width; x += 1){
              // Расcчитаем среднее значение "y" для двух линий в точке "x".
              int midlePoint = (arr_lines[l][x] + arr_Y[x]) / 2;
              // Перезапишем линию в массив.
              arr_lines[l][x] = midlePoint;
            }

            // Флаг указывает что линия является повторением уже существующей.
            newLine = false;
          }
        }
        // Если флаг указывает что линия является уникальной и массив arr_lines не переполнен.
        if(newLine && linesSorted < 6){
          // Линию из массива хранящего линию для проверки запишем в массив хранящий все линии.
          for(int x = 0; x < width; x += 1){
            arr_lines[linesSorted][x] =  arr_Y[x];
          }
          // В массив arr_lines добавлена одна линия.
          linesSorted += 1;
        }
      }
    }

    // Пройдём по каждой линии массива хранящего все линии.
    for(int l = 0; l < linesSorted; l += 1){
      // Пройдём по каждой точке текущей линии.
      for(int x = 0; x < width; x += 1){
        // Если координата "Y" (высота) не выходит за рамки изображения
        if(arr_lines[l][x] > 0 && arr_lines[l][x] < height){
          // Рассчитать индекс для буфера изображения прямых линий, построеных по данным из пространства Хафа,
          // соответствующий точке с расчитанными координатами для прямой линнии .
          int bufIndexFound = arr_lines[l][x] * width + x;
          // Если рассчитаный индекс не превышает размер буфера
          if(bufIndexFound < len){
            // покрасить соответсвующий пиксель в белый.
            buf[bufIndexFound] = 250;
          }
        }
      }
    }
  }







/** Функция для построения найденых линий на исходном изображении.
uint8_t * &buf_jpeg - буфер с исходным изображением.
size_t &len_jpeg - размер буфера.
int width - ширина исходного изображения.
int height высота исходного изображения.
int arr_lines[6][238] - массив под хранение координат отфильтрованых линий по данным из пространства Хафа.
int linesSorted - кол-во найденых отфильтрованых линий.**/
void drawRGBLines(uint8_t * &buf_jpeg, size_t &len_jpeg, int width, int height, int arr_lines[6][238], int linesSorted) {
  // Размер буффера для хранения исходного изображения преобразованого в цветовую матрицу RGB.
  size_t  len_rgb = width * height * 3;
  // Инициализировать буфер под хранение исходного изображения преобразованого в цветовую матрицу RGB.
  uint8_t *buf_rgb = (uint8_t *)ps_malloc(len_rgb);

  
  // Конвертируем исходное изображение в цветовую матрицу RGB.
  bool okey = fmt2rgb888(buf_jpeg, len_jpeg, PIXFORMAT_JPEG, buf_rgb);

  for(int y = 0; y < linesSorted; y++){
    for(int x = 0; x < width; x += 1){
      // Если координата "Y" (высота) не выходит за рамки изображения
      if(arr_lines[y][x] > 0 && arr_lines[y][x] < height){
        int index = (arr_lines[y][x] * width * 3) + (x * 3);

        buf_rgb[index] = 0;
        buf_rgb[index + 1] = 255;
        buf_rgb[index + 2] = 0;
      }
    }
  }

  // Освобождаем буфер для того чтобы перезаписать его.
  if (buf_jpeg) free(buf_jpeg);
  // Конвертируем цветовую матрицу в сжатое изображение в формате JPEG.
   bool ok = fmt2jpg(buf_rgb, len_rgb, width, height, PIXFORMAT_RGB888, 80, &buf_jpeg, &len_jpeg);
  // Освобождаем буфер хранящий цветовую матрицу.
  if (buf_rgb) free(buf_rgb);
}
