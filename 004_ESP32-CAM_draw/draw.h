// Cтандартная библиотека с набором математических функций.
#include <cmath>

/** Функция для отрисовки круга.
    uint8_t * &buf - изображение на которое будет нанесён круг.
    int x - координата центра круга.
    int y -  координата центра круга.
    int radius - радиус круга.
    int width - ширина изображения.
    int height - высота изображения.**/
void drawCircle(uint8_t * &buf, int x, int y, int radius, int width, int height) {

  // Корректируем часть аргументов для более удобной работы:
  // Отсчёт координат начинается с 0, а не 1.
  int y_real = y - 1;
  // Сдвигаем координату "x", так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int x_real = (x - 1) * 3;
  // Увеличиваем ширину изображения, так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int width_real = width * 3;

  // Если окружность не выходит за границы изображения.
  if (x + radius < width + 1 && y + radius < height + 1) {
    // В заданой точке начертить окружность. 
    // Окружность это 360 градусов, для каждого направления требуется расчитать точку.
    for(int i = 0; i < 360 ; i += 1){
      // Угол для радиуса проведённого из центра окружности к расчитываемой точке.
      float theta = i*PI/180.0;
      // Координата x расчитываемой точки окружности с учётом, что на каждый 
      // пиксель приходиться 3 компоненты цвета RGB.
      int xc = x_real + (radius * cos(theta)) * 3;
      // Координата y расчитываемой точки.
      int yc = y_real + radius*sin(theta);
      // Индекс расчитываемой точки в буфере содержащем изображение.
      int bufIndex = yc * width_real + xc;

      // Закрашиваем рассчитанную точку окружности:
      // Красная компонента цвета.
      buf[bufIndex+2] = 255;
      // Зелёная компонента цвета.
      buf[bufIndex+1] = 255;
      // Голубая компонента цвета.
      buf[bufIndex] = 255;
    }     
  } else {
    Serial.println("The circle has gone beyond the image border!");
  }
}


/** Функция для отрисовки разного.
    uint8_t * &buf - изображение на котором будем рисовать.
    int x - координата точки на которую будем опираться при рисовании.
    int y -  координата центра круга.
    int width_img - ширина изображения.
    int height_img - высота изображения.
    int width_img - ширина области в которой будем рисовать.
    int height_img - высота изображения в которой будем рисовать.**/
void risovalka(uint8_t * &buf, int x, int y, int width_img, int height_img, int width, int height) {
  
  // Корректируем часть аргументов для более удобной работы:
  // Отсчёт координат начинается с 0, а не 1.
  int y_real = y - 1;
  // Сдвигаем координату "x", так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int x_real = (x - 1) * 3;
  // Увеличиваем ширину изображения, так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int width_img_real = width_img * 3;
  // Увеличиваем ширину области в которой будем рисовать, так как на каждый пиксель приходиться 3 компоненты цвета RGB.
  int width_real = width * 3;


  // Если заданый участок не выходит за границы изображения.
  if (x + width < width_img + 1 && y + height < height_img + 1) {
    // Пройти через все пиксели на заданом участке изображения.
    for(int i = x_real; i < x_real + width_real; i += 3){
      for(int j = y_real; j < y_real + height; j += 1){

        // Уменьшить яркость в заданой области.
        buf[i + width_img_real * j + 2] = (byte) (buf[i + width_img_real * j + 2] * 0.8);
        buf[i + width_img_real * j + 1] = (byte) (buf[i + width_img_real * j + 1] * 0.8);
        buf[i + width_img_real * j] = (byte) (buf[i + width_img_real * j] * 0.8);
      }     
    }
  } else {
    Serial.println("Wrong width or height!");
  }
}